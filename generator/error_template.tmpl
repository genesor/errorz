// Code generated by http://github.com/genesor/errorz (v1.0.0). DO NOT EDIT.

package errorz

import (
	"fmt"
	"net/http"
)

// {{.Name}}Error is used {{.UseCase}}.
type {{.Name}}Error struct {
	*ErrorWithKey
}

// New{{.Name}}Error is used {{.UseCase}}.
func New{{.Name}}Error(code, key string) error {
	return WrapWith{{.Name}}Error(nil, code, key)
}

// New{{.Name}}Errorf is used {{.UseCase}}.
func New{{.Name}}Errorf(code, key string, args ...any) error {
	return WrapWith{{.Name}}Errorf(nil, code, key, args...)
}

// WrapWith{{.Name}}Error is used {{.UseCase}}.
func WrapWith{{.Name}}Error(err error, code, key string) error {
	return NewError[{{.Name}}Error](code, key, http.{{.HTTPCode}}, err)
}

// WrapWith{{.Name}}Errorf is used {{.UseCase}}.
func WrapWith{{.Name}}Errorf(err error, code, key string, args ...any) error {
	return NewError[{{.Name}}Error](code, fmt.Sprintf(key, args...), http.{{.HTTPCode}}, err)
}

// Is{{.Name}}Error identifies an error as an {{.Name}}Error.
func Is{{.Name}}Error(err error) bool {
	return Is[{{.Name}}Error](err)
}

// As{{.Name}}Error tries to cast an error as an {{.Name}}Error.
func As{{.Name}}Error(err error) (*{{.Name}}Error, bool) {
	return As[{{.Name}}Error](err)
}

// Is is used by the standard "errors" package to identify an error as {{.Name}}Error.
func (e *{{.Name}}Error) Is(err error) bool {
	_, ok := err.(*{{.Name}}Error)
	return ok
}

// As is used by the standard "errors" package to identify an error as {{.Name}}Error.
func (e *{{.Name}}Error) As(err interface{}) bool {
	err2, ok := err.(*{{.Name}}Error)
	if ok {
		*err2 = *e
	}
	return ok
}

// Unwrap is used by the standard "errors" package to dive into the error chain.
func (e *{{.Name}}Error) Unwrap() error {
	return e.ErrorWithKey
}
